{"remainingRequest":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/thread-loader/dist/cjs.js!/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/babel-loader/lib/index.js!/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/ts-loader/index.js??ref--14-3!/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/eslint-loader/index.js??ref--13-0!/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/src/util/forms.ts","dependencies":[{"path":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/src/util/forms.ts","mtime":1589906836721},{"path":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/cache-loader/dist/cjs.js","mtime":1584795984278},{"path":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/thread-loader/dist/cjs.js","mtime":1584795984506},{"path":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/babel-loader/lib/index.js","mtime":1584795984276},{"path":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/ts-loader/index.js","mtime":1586724162024},{"path":"/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/eslint-loader/index.js","mtime":1584795992192}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2giOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZW50cmllcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5mcm9tLWVudHJpZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoIjsKCi8qKgogKiBNb2R1bGUgcHJvdmlkaW5nIHV0aWxpdHkgbWl4aW5zIGZvciBjcmVhdGluZyB3cmFwcGVyIGNvbnRyb2xzIG9yIGZvcm0KICogY29udHJvbCBncm91cHMgb3BlcmF0aW5nIHdpdGggQW50RFYgZm9ybXMuCiAqLwppbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7CmltcG9ydCAqIGFzIHR5cGluZyBmcm9tICdAL3V0aWwvdHlwaW5nJzsgLy8gPj4+Pj4gSEVMUEVSIEZVTkNUSU9OICYgREVDTEFSQVRJT04gU0VDVElPTiA+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4KLy8gUmVhbGlzZSBjYW1lbENhc2UgcHJlZml4aW5nLCB3aGVyZWFzIHRoZSBwcmVmaXhlZCBuYW1lIHN0YXJ0cyB3aXRoIGNhcGl0YWwKCmZ1bmN0aW9uIHByZWZpeGVkKG5hbWUsIHByZWZpeCkgewogIGlmICghcHJlZml4KSB7CiAgICByZXR1cm4gbmFtZTsKICB9IGVsc2UgewogICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTsKICB9Cn0KLyoqCiAqIE1peGluIHByb3ZpZGluZyB1dGlsaXR5IGZ1bmN0aW9uYWxpdHkgbGlrZSBwcmVmaXhpbmcgYW5kIHJlLW1hcHBpbmcgZmllbGQKICogbmFtZXMgYW5kIGFjY2Vzc2luZyBmaWVsZCB2YWx1ZXMgZm9yIGZvcm0gZ3JvdXAgY29tcG9uZW50cy4KICoKICogRm9yIHVzaW5nIHRoaXMgbWl4aW4gZWZmZWN0aXZlbHksIHlvdSBoYXZlIHRvCiAqCiAqICAtIHNwZWNpZnkgZmllbGQgaWRlbnRpZmllcnMgZm9yIGFsbCB0aGUgZmllbGRzIHRoYXQgc2hhbGwgYmUgbWFuYWdlZCBieSB0aGUKICogICAgaW1wbGVtZW50aW5nIGZvcm0gZ3JvdXAgYnkgZGVmaW5pbmcgdGhlIGBmaWVsZElkZW50aWZpZXJzYCBvcHRpb24gd2l0aCBhbgogKiAgICBhcnJheSBvZiB0aG9zZSBuYW1lcy4gRmllbGQgaWRlbnRpZmllcnMgYXJlIHF1aXRlIHNpbWlsYXIgdG8gZm9ybSBmaWVsZAogKiAgICBuYW1lcywgYnV0IG1heSBub3QgYmUgdW5pcXVlIGFjcm9zcyB0aGUgd2hvbGUgZm9ybS4gVGhlcmVmb3JlLCBmaWVsZAogKiAgICBpZGVudGlmaWVycyBhcmUgb25seSB2YWxpZCB3aXRoaW4gYW4gaW5zdGFuY2Ugb2YgdGhlIGZvcm0gZ3JvdXAgd2hlcmUKICogICAgdGhleSBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlIG1hbmFnZWQgZmllbGRzJyB2YWx1ZXMuCiAqCiAqICAtIHVzZSB0aGUgYGZvcm1GaWVsZE5hbWVgIGZ1bmN0aW9uIGluIGZpZWxkIGRlY29yYXRvciBkZWZpbml0aW9ucyB0aGF0IHdpbGwKICogICAgdHJhbnNsYXRlIHRoZSBnaXZlbiBhc3NpZ25lZCBmaWVsZCBpZGVudGlmaWVyIGludG8gdGhlIGZpZWxkJ3MgbmFtZSB3aXRoaW4KICogICAgdGhlIGZvcm0uIEJ5IGRvaW5nIHNvLCBjb21wb25lbnRzIHVzaW5nIHRoZSBmb3JtIGdyb3VwIGNhbiBhZGFwdCB0aGUgbmFtZXMKICogICAgb2YgdGhlIGZvcm0gZ3JvdXAgaW5zdGFuY2UncyBmaWVsZHMgYXMgcmVxdWlyZWQgYnkgZXh0ZXJuYWwgY29uZGl0aW9ucyBhbmQKICogICAgdW5pcXVlbmVzcyBhY3Jvc3MgdGhlIGZvcm0uCiAqCiAqIFNlZSB0eXBlIGludGVyZmFjZSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgZXhwb3NlZCBBUEkuCiAqLwoKCmV4cG9ydCB2YXIgRm9ybUdyb3VwTWl4aW4gPSBWdWUuZXh0ZW5kKHsKICBwcm9wczogewogICAgZmllbGROYW1lUHJlZml4OiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogdW5kZWZpbmVkCiAgICB9LAogICAgZmllbGRJZGVudGlmaWVyczogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkgewogICAgICAgIHJldHVybiB7fTsKICAgICAgfQogICAgfSwKICAgIGlucHV0UHJvcHM6IHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHsKICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuJG9wdGlvbnMuZmllbGRJZGVudGlmaWVycy5tYXAoZnVuY3Rpb24gKGtleSkgewogICAgICAgICAgcmV0dXJuIFtrZXksIHt9XTsKICAgICAgICB9KSk7CiAgICAgIH0KICAgIH0KICB9LAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBmb3JtRmllbGROYW1lQmFja1RyYW5zbGF0aW9uOiB7fQogICAgfTsKICB9LAogIGluamVjdDogewogICAgRm9ybUNvbnRleHQ6IHsKICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7CiAgICAgICAgcmV0dXJuIHt9OwogICAgICB9CiAgICB9CiAgfSwKICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkgewogICAgdmFyIF90aGlzID0gdGhpczsKCiAgICBpZiAodGhpcy4kb3B0aW9ucy5maWVsZElkZW50aWZpZXJzKSB7CiAgICAgIHRoaXMuJG9wdGlvbnMuZmllbGRJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZElkKSB7CiAgICAgICAgX3RoaXMuZm9ybUZpZWxkTmFtZUJhY2tUcmFuc2xhdGlvbltfdGhpcy5mb3JtRmllbGROYW1lKGZpZWxkSWQpXSA9IGZpZWxkSWQ7CiAgICAgIH0pOwogICAgfQogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgIGlmICh0aGlzLiRvcHRpb25zLmZpZWxkSWRlbnRpZmllcnMpIHsKICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtIGl0ZW1zIHVzZSBzZWxmVXBkYXRlOyB0aGlzIGlzIGNydWNpYWwgZm9yIGZvcm0gaXRlbXMKICAgICAgLy8gaW4gdGhlIGdyb3VwIHRvIGJlIHJlLXJlbmRlcmVkIGNvcnJlY3RseSB3aGVuIG5ldyB2YWx1ZXMgYXJlIHNldAogICAgICB0aGlzLiRvcHRpb25zLmZpZWxkSWRlbnRpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgaWYgKF90aGlzMi5nZXRGb3JtQ29udGV4dCgpLmZvcm0uZm9ybUl0ZW1zW190aGlzMi5mb3JtRmllbGROYW1lKGtleSldLml0ZW1TZWxmVXBkYXRlKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJbICIuY29uY2F0KF90aGlzMi4kb3B0aW9ucy5uYW1lLCAiIF06ICIpICsgImBpdGVtU2VsZlVwZGF0ZWAgaXMgbm90IGVuYWJsZWQgZm9yIGZvcm0gaXRlbSBvZiBgIi5jb25jYXQoa2V5LCAiYC4gIikgKyAnVGhpcyBtYXkgbGVhZCB0byBjb250ZW50cyBub3QgYmVpbmcgcmUtcmVuZGVyZWQgd2hlbiB0aGVpciAnICsgJ3ZhbHVlIGlzIG1vZGlmaWVkIGJ5IGNhbGxpbmcgYHNldEZpZWxkc1ZhbHVlYCBvbiBpdHMgJyArICdjb250YWluaW5nIGZvcm0uIFRvIGZpeCB0aGlzLCBhZGQgYDpzZWxmVXBkYXRlPSJ0cnVlImAgdG8gJyArICJ0aGUgYGEtZm9ybS1pdGVtYCBjb21wb25lbnQgY29udGFpbmluZyB0aGUgYCIuY29uY2F0KGtleSwgImAgY29udHJvbCAiKSArICdvciBhZGQgYDpzZWxmVXBkYXRlPSJ0cnVlImAgdG8gdGhlIHJvb3QgYGEtZm9ybWAgZWxlbWVudC4nKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0sCiAgbWV0aG9kczogewogICAgZ2V0Rm9ybUNvbnRleHQ6IGZ1bmN0aW9uIGdldEZvcm1Db250ZXh0KCkgewogICAgICByZXR1cm4gdHlwaW5nLmV4dGVuZGVkKHRoaXMsIHR5cGluZy5UeXBlQXJnKCkpLkZvcm1Db250ZXh0OwogICAgfSwKICAgIGZvcm1GaWVsZE5hbWU6IGZ1bmN0aW9uIGZvcm1GaWVsZE5hbWUoa2V5KSB7CiAgICAgIHZhciBwcm9wS2V5cyA9IHRoaXMuJHByb3BzLmZpZWxkTmFtZXM7CiAgICAgIHJldHVybiBwcm9wS2V5cyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcEtleXMsIGtleSkgPyBwcm9wS2V5c1trZXldIDogcHJlZml4ZWQoa2V5LCB0aGlzLiRwcm9wcy5maWVsZE5hbWVQcmVmaXgpOwogICAgfSwKICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YSwgdXNlc0Zvcm1GaWVsZE5hbWVzKSB7CiAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgaWYgKCF0aGlzLiRvcHRpb25zLmZpZWxkSWRlbnRpZmllcnMpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlsgIi5jb25jYXQodGhpcy4kb3B0aW9ucy5uYW1lLCAiIF06IGBzZXREYXRhYCBub3Qgc3VwcG9ydGVkIikpOwogICAgICB9IC8vIENoZWNrIGlmIGNvbnZlcnNpb24gb2YgaWRlbnRpZmllcnMgdG8gZmllbGQgbmFtZXMgaXMgcmVxdWlyZWQKCgogICAgICBpZiAoIXVzZXNGb3JtRmllbGROYW1lcykgewogICAgICAgIGRhdGEgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKGZ1bmN0aW9uIChlbnRyeSkgewogICAgICAgICAgcmV0dXJuIFtfdGhpczMuZm9ybUZpZWxkTmFtZShlbnRyeVswXSksIGVudHJ5WzFdXTsKICAgICAgICB9KSk7CiAgICAgIH0gLy8gRmlsdGVyIG91dCBhbnkgbmFtZXMgdGhhdCBkbyBub3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgaWRlbnRpZmllcgogICAgICAvLyBkZWZpbmVkIHVzaW5nIHRoZSBmaWVsZElkZW50aWZpZXJzIG9wdGlvbgoKCiAgICAgIHZhciBmaWVsZE5hbWVzID0gdGhpcy4kb3B0aW9ucy5maWVsZElkZW50aWZpZXJzLm1hcCh0aGlzLmZvcm1GaWVsZE5hbWUpOwogICAgICBkYXRhID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICByZXR1cm4gZmllbGROYW1lcy5pbmNsdWRlcyh2YWx1ZVswXSk7CiAgICAgIH0pKTsgLy8gU2V0IHRoZSB2YWx1ZXMKCiAgICAgIHRoaXMuZ2V0Rm9ybUNvbnRleHQoKS5mb3JtLnNldEZpZWxkc1ZhbHVlKGRhdGEpOwogICAgfSwKICAgIGdldERhdGE6IGZ1bmN0aW9uIGdldERhdGEoZmllbGROYW1lcywgdXNlc0Zvcm1GaWVsZE5hbWVzKSB7CiAgICAgIHZhciBfdGhpczQgPSB0aGlzOwoKICAgICAgaWYgKCF0aGlzLiRvcHRpb25zLmZpZWxkSWRlbnRpZmllcnMpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlsgIi5jb25jYXQodGhpcy4kb3B0aW9ucy5uYW1lLCAiIF06IGBnZXREYXRhYCBub3Qgc3VwcG9ydGVkIikpOwogICAgICB9CgogICAgICBpZiAoZmllbGROYW1lcyAhPT0gdW5kZWZpbmVkICYmICF1c2VzRm9ybUZpZWxkTmFtZXMpIHsKICAgICAgICAvLyBmaWVsZE5hbWVzIGNvbnRhaW5zIGZpZWxkIGlkZW50aWZpZXJzIHRoYXQgbmVlZCB0byBiZSB0cmFuc2xhdGVkCiAgICAgICAgZmllbGROYW1lcyA9IGZpZWxkTmFtZXMubWFwKGZ1bmN0aW9uIChmaWVsZElkKSB7CiAgICAgICAgICB2YXIgZm9ybUZpZWxkTmFtZSA9IF90aGlzNC5mb3JtRmllbGROYW1lKGZpZWxkSWQpOwoKICAgICAgICAgIHJldHVybiBmb3JtRmllbGROYW1lOwogICAgICAgIH0pOwogICAgICB9CgogICAgICB2YXIgcGVybWl0dGVkRmllbGROYW1lcyA9IHRoaXMuJG9wdGlvbnMuZmllbGRJZGVudGlmaWVycy5tYXAodGhpcy5mb3JtRmllbGROYW1lKTsKCiAgICAgIGlmIChmaWVsZE5hbWVzID09PSB1bmRlZmluZWQpIHsKICAgICAgICAvLyBObyBzcGVjaWZpYyBmaWVsZCBuYW1lcyBzcGVjaWZpZWQgaXMgZXF1aXZhbGVudCB0byBnZXR0aW5nIHRoZW0gYWxsCiAgICAgICAgZmllbGROYW1lcyA9IHBlcm1pdHRlZEZpZWxkTmFtZXM7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gRmlsdGVyIG91dCBhbnkgbmFtZXMgdGhhdCBkbyBub3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgaWRlbnRpZmllcgogICAgICAgIC8vIGRlZmluZWQgdXNpbmcgdGhlIGZpZWxkSWRlbnRpZmllcnMgb3B0aW9uCiAgICAgICAgZmllbGROYW1lcyA9IGZpZWxkTmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHsKICAgICAgICAgIHJldHVybiBwZXJtaXR0ZWRGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSk7CiAgICAgICAgfSk7CiAgICAgIH0gLy8gUmV0cmlldmUgdGhlIHJlcXVlc3RlZCB2YWx1ZXM7IGlmIGZpZWxkIG5hbWVzIGhhdmUgYmVlbiBzcGVjaWZpZWQKICAgICAgLy8gYXMgZmllbGQgaWRlbnRpZmllcnMsIHRoZSByZXN1bHQncyBrZXlzIHdpbGwgYmUgdHJhbnNsYXRlZCBiYWNrCgoKICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0Rm9ybUNvbnRleHQoKS5mb3JtLmdldEZpZWxkc1ZhbHVlKGZpZWxkTmFtZXMpOwoKICAgICAgaWYgKCF1c2VzRm9ybUZpZWxkTmFtZXMpIHsKICAgICAgICByZXN1bHQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmVzdWx0KS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7CiAgICAgICAgICByZXR1cm4gW190aGlzNC5mb3JtRmllbGROYW1lQmFja1RyYW5zbGF0aW9uW2VudHJ5WzBdXSwgZW50cnlbMV1dOwogICAgICAgIH0pKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0sCiAgICBnZXRTaW5nbGVWYWx1ZTogZnVuY3Rpb24gZ2V0U2luZ2xlVmFsdWUoZmllbGROYW1lLCB1c2VzRm9ybUZpZWxkTmFtZXMpIHsKICAgICAgdmFyIGtleSA9IHVzZXNGb3JtRmllbGROYW1lcyA/IGZpZWxkTmFtZSA6IHRoaXMuZm9ybUZpZWxkTmFtZShmaWVsZE5hbWUpOwogICAgICByZXR1cm4gdGhpcy5nZXREYXRhKFtrZXldLCB0cnVlKVtrZXldOwogICAgfQogIH0KfSk7Ci8qKgogKiBNaXhpbiBwcm92aWRpbmcgdXRpbGl0eSBmdW5jdGlvbmFsaXR5IHRvIGZvcm0gY29udHJvbHMgb3IgQW50RFYgZm9ybSBjb250cm9sCiAqIHdyYXBwZXJzLgogKgogKiBTZWUgdHlwZSBpbnRlcmZhY2UgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBleHBvc2VkIEFQSS4KICovCgpleHBvcnQgdmFyIEZvcm1Db250cm9sTWl4aW4gPSBWdWUuZXh0ZW5kKHsKICBpbmplY3Q6IHsKICAgIEZvcm1Db250ZXh0OiB7CiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkgewogICAgICAgIHJldHVybiB7fTsKICAgICAgfQogICAgfQogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIGZpZWxkTmFtZTogZnVuY3Rpb24gZmllbGROYW1lKCkgewogICAgICBpZiAodGhpcy5nZXRGb3JtQ29udGV4dCgpICYmIHRoaXMuJGF0dHJzWydkYXRhLV9fZmllbGQnXSkgewogICAgICAgIHJldHVybiB0eXBpbmcuY2FzdCh0aGlzLiRhdHRyc1snZGF0YS1fX2ZpZWxkJ10pLm5hbWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgIH0KICB9LAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBGb3JtQ29udHJvbENvbnZWYWx1ZTogdW5kZWZpbmVkCiAgICB9OwogIH0sCiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHsKICAgIHZhciBfdGhpczUgPSB0aGlzOwoKICAgIGlmICh0aGlzLiRvcHRpb25zLmZpZWxkVmFsdWVDb252ZXJ0KSB7CiAgICAgIHZhciB2YWx1ZVByb3AgPSB0aGlzLiRvcHRpb25zLm1vZGVsICYmIHRoaXMuJG9wdGlvbnMubW9kZWwucHJvcCA/IHRoaXMuJG9wdGlvbnMubW9kZWwucHJvcCA6ICd2YWx1ZSc7CiAgICAgIHRoaXMuJHdhdGNoKHZhbHVlUHJvcCwgZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgaWYgKF90aGlzNS5Gb3JtQ29udHJvbENvbnZWYWx1ZSA9PT0gdmFsdWUpIHsKICAgICAgICAgIC8vIFZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkCiAgICAgICAgICBfdGhpczUuRm9ybUNvbnRyb2xDb252VmFsdWUgPSB1bmRlZmluZWQ7CiAgICAgICAgfSBlbHNlIGlmIChfdGhpczUuJG9wdGlvbnMuZmllbGRWYWx1ZUNvbnZlcnQpIHsKICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzNS4kb3B0aW9ucy5maWVsZFZhbHVlQ29udmVydC5jYWxsKF90aGlzNSwgdmFsdWUpOwoKICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHsKICAgICAgICAgICAgX3RoaXM1LkZvcm1Db250cm9sQ29udlZhbHVlID0gbmV3VmFsdWU7CgogICAgICAgICAgICBfdGhpczUuc2V0T3duVmFsdWUobmV3VmFsdWUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBnZXRGb3JtQ29udGV4dDogZnVuY3Rpb24gZ2V0Rm9ybUNvbnRleHQoKSB7CiAgICAgIHJldHVybiB0eXBpbmcuZXh0ZW5kZWQodGhpcywgdHlwaW5nLlR5cGVBcmcoKSkuRm9ybUNvbnRleHQ7CiAgICB9LAogICAgaXNEZWNvcmF0ZWRGb3JtRmllbGQ6IGZ1bmN0aW9uIGlzRGVjb3JhdGVkRm9ybUZpZWxkKCkgewogICAgICByZXR1cm4gISEodGhpcy5nZXRGb3JtQ29udGV4dCgpICYmIHRoaXMuJGF0dHJzWydkYXRhLV9fZmllbGQnXSk7CiAgICB9LAogICAgc2V0T3duVmFsdWU6IGZ1bmN0aW9uIHNldE93blZhbHVlKHZhbHVlKSB7CiAgICAgIHZhciBldmVudFR5cGUgPSB0aGlzLiRvcHRpb25zLm1vZGVsICYmIHRoaXMuJG9wdGlvbnMubW9kZWwuZXZlbnQgPyB0aGlzLiRvcHRpb25zLm1vZGVsLmV2ZW50IDogJ2NoYW5nZSc7CiAgICAgIHRoaXMuJGVtaXQoZXZlbnRUeXBlLCB2YWx1ZSk7CiAgICB9LAogICAgZ2V0T3duVmFsdWU6IGZ1bmN0aW9uIGdldE93blZhbHVlKCkgewogICAgICB2YXIgdmFsdWVQcm9wID0gdGhpcy4kb3B0aW9ucy5tb2RlbCAmJiB0aGlzLiRvcHRpb25zLm1vZGVsLnByb3AgPyB0aGlzLiRvcHRpb25zLm1vZGVsLnByb3AgOiAndmFsdWUnOwogICAgICByZXR1cm4gdGhpc1t2YWx1ZVByb3BdOwogICAgfQogIH0KfSk7"},{"version":3,"sources":["/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/node_modules/eslint-loader/index.js??ref--13-0!/home/cirotzki/projects/virus/1_011_a_infektionsfall_uebermittellung/client/src/util/forms.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Module providing utility mixins for creating wrapper controls or form\n * control groups operating with AntDV forms.\n */\n\nimport Vue, { PropType } from 'vue'\nimport * as typing from '@/util/typing'\n\n// >>>>> HELPER FUNCTION & DECLARATION SECTION >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n// Realise camelCase prefixing, whereas the prefixed name starts with capital\nfunction prefixed(name: string, prefix?: string): string {\n  if (!prefix) {\n    return name\n  } else {\n    return prefix + name.charAt(0).toUpperCase() + name.substring(1)\n  }\n}\n\ninterface MinimalFormContext {\n  form: {\n    formItems: Record<\n      string,\n      {\n        itemSelfUpdate: boolean\n      }\n    >\n    setFieldsValue(vals: Record<string, any>): void\n    getFieldsValue(names?: string[]): Record<string, any>\n  }\n}\n\n// >>>>> MIXIN DEFINITIONS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\ndeclare module 'vue/types/options' {\n  interface ComponentOptions<V extends Vue> {\n    fieldIdentifiers?: string[]\n  }\n}\n\nexport interface FormGroupMixin {\n  $options: {\n    /**\n     * Array of all the field identifiers used for the fields managed by\n     * this form group component.\n     */\n    fieldIdentifiers?: string[]\n  }\n\n  $props: {\n    /**\n     * Optional prefix to be applied to all field names.\n     */\n    fieldNamePrefix?: string\n    /**\n     * Optional mapping of field identifiers to custom field names for some\n     * or all fields. The names of fields not specified in this map are subject\n     * to default field naming, respecting a provided field name prefix.\n     */\n    fieldNames?: Record<string, string>\n    /**\n     * Optional props to apply to some or all fields. The top level key\n     * is the identifier of the form field with a map of the props to apply\n     * to that field as the respective value.\n     */\n    controlProps?: Record<string, Record<string, any>>\n  }\n\n  /**\n   * Generates the name to be used for the field with the given identifier,\n   * according to field name overrides (see inputKeys prop) and field name\n   * prefixing (see inputKeyPrefix prop). This function is typically called\n   * to generate the appropriate field name for the v-decorator directive.\n   */\n  formFieldName(fieldId: string): string\n\n  /**\n   * Sets some or all fields of this form group. The second parameter specifies\n   * whether the passed key-value mapping's keys specify field identifiers or\n   * the actual field names as used in the form.\n   */\n  setData(data: Record<string, any>, usesFormFieldNames?: boolean): void\n  /**\n   * Retrieves the values of some or all fields of this form group. The optional\n   * second parameter specifies whether the given field name array specifies\n   * field identifiers or the actual field names as used in the form. The result\n   * mapping will map the values by the same names.\n   */\n  getData(\n    fieldNames?: string[],\n    usesFormFieldNames?: boolean\n  ): Record<string, any>\n  /**\n   * Retrieves the value of one specific field of this form group. The optional\n   * second parameter specifies whether the given field name array specifies\n   * field identifiers or the actual field names as used in the form.\n   */\n  getSingleValue(\n    fieldName: string,\n    usesFormFieldNames?: boolean\n  ): any | undefined\n}\n\n/**\n * Mixin providing utility functionality like prefixing and re-mapping field\n * names and accessing field values for form group components.\n *\n * For using this mixin effectively, you have to\n *\n *  - specify field identifiers for all the fields that shall be managed by the\n *    implementing form group by defining the `fieldIdentifiers` option with an\n *    array of those names. Field identifiers are quite similar to form field\n *    names, but may not be unique across the whole form. Therefore, field\n *    identifiers are only valid within an instance of the form group where\n *    they can be used to access the managed fields' values.\n *\n *  - use the `formFieldName` function in field decorator definitions that will\n *    translate the given assigned field identifier into the field's name within\n *    the form. By doing so, components using the form group can adapt the names\n *    of the form group instance's fields as required by external conditions and\n *    uniqueness across the form.\n *\n * See type interface for information about exposed API.\n */\nexport const FormGroupMixin = Vue.extend({\n  props: {\n    fieldNamePrefix: {\n      type: String as PropType<string>,\n      default: undefined,\n    },\n    fieldIdentifiers: {\n      type: Object as PropType<Record<string, string>>,\n      default: () => ({}),\n    },\n    inputProps: {\n      type: Object as PropType<Record<string, Record<string, any>>>,\n      default(): Record<string, Record<string, any>> {\n        return Object.fromEntries(\n          this.$options.fieldIdentifiers!.map((key: string) => [key, {}])\n        )\n      },\n    },\n  },\n  data() {\n    return {\n      formFieldNameBackTranslation: {} as Record<string, string>,\n    }\n  },\n  inject: {\n    FormContext: { default: () => ({}) },\n  },\n  created() {\n    if (this.$options.fieldIdentifiers) {\n      this.$options.fieldIdentifiers.forEach((fieldId: string) => {\n        this.formFieldNameBackTranslation[this.formFieldName(fieldId)] = fieldId\n      })\n    }\n  },\n  mounted(): void {\n    if (this.$options.fieldIdentifiers) {\n      // Make sure all form items use selfUpdate; this is crucial for form items\n      // in the group to be re-rendered correctly when new values are set\n      this.$options.fieldIdentifiers.forEach((key: string) => {\n        if (\n          this.getFormContext().form.formItems[this.formFieldName(key)]\n            .itemSelfUpdate\n        ) {\n          console.error(\n            `[ ${this.$options.name} ]: ` +\n              `\\`itemSelfUpdate\\` is not enabled for form item of \\`${key}\\`. ` +\n              'This may lead to contents not being re-rendered when their ' +\n              'value is modified by calling `setFieldsValue` on its ' +\n              'containing form. To fix this, add `:selfUpdate=\"true\"` to ' +\n              `the \\`a-form-item\\` component containing the \\`${key}\\` control ` +\n              'or add `:selfUpdate=\"true\"` to the root `a-form` element.'\n          )\n        }\n      })\n    }\n  },\n  methods: {\n    getFormContext() {\n      return typing.extended(\n        this,\n        typing.TypeArg<{\n          FormContext: MinimalFormContext\n        }>()\n      ).FormContext\n    },\n    formFieldName(key: string): string {\n      const propKeys = this.$props.fieldNames\n      return propKeys && Object.prototype.hasOwnProperty.call(propKeys, key)\n        ? propKeys[key]\n        : prefixed(key, this.$props.fieldNamePrefix)\n    },\n    setData(data: Record<string, any>, usesFormFieldNames?: boolean) {\n      if (!this.$options.fieldIdentifiers) {\n        throw new Error(`[ ${this.$options.name} ]: \\`setData\\` not supported`)\n      }\n\n      // Check if conversion of identifiers to field names is required\n      if (!usesFormFieldNames) {\n        data = Object.fromEntries(\n          Object.entries(data).map((entry: [string, any]) => [\n            this.formFieldName(entry[0]),\n            entry[1],\n          ])\n        )\n      }\n\n      // Filter out any names that do not have a corresponding identifier\n      // defined using the fieldIdentifiers option\n      const fieldNames = this.$options.fieldIdentifiers.map(this.formFieldName)\n      data = Object.fromEntries(\n        Object.entries(data).filter((value: [string, any]) =>\n          fieldNames.includes(value[0])\n        )\n      )\n\n      // Set the values\n      this.getFormContext().form.setFieldsValue(data)\n    },\n    getData(\n      fieldNames?: string[],\n      usesFormFieldNames?: boolean\n    ): Record<string, any> {\n      if (!this.$options.fieldIdentifiers) {\n        throw new Error(`[ ${this.$options.name} ]: \\`getData\\` not supported`)\n      }\n\n      if (fieldNames !== undefined && !usesFormFieldNames) {\n        // fieldNames contains field identifiers that need to be translated\n        fieldNames = fieldNames.map((fieldId: string) => {\n          const formFieldName = this.formFieldName(fieldId)\n          return formFieldName\n        })\n      }\n\n      const permittedFieldNames = this.$options.fieldIdentifiers.map(\n        this.formFieldName\n      )\n      if (fieldNames === undefined) {\n        // No specific field names specified is equivalent to getting them all\n        fieldNames = permittedFieldNames\n      } else {\n        // Filter out any names that do not have a corresponding identifier\n        // defined using the fieldIdentifiers option\n        fieldNames = fieldNames.filter((fieldName: string) =>\n          permittedFieldNames.includes(fieldName)\n        )\n      }\n\n      // Retrieve the requested values; if field names have been specified\n      // as field identifiers, the result's keys will be translated back\n      let result = this.getFormContext().form.getFieldsValue(fieldNames)\n      if (!usesFormFieldNames) {\n        result = Object.fromEntries(\n          Object.entries(result).map((entry: [string, any]) => [\n            this.formFieldNameBackTranslation[entry[0]],\n            entry[1],\n          ])\n        )\n      }\n\n      return result\n    },\n    getSingleValue(\n      fieldName: string,\n      usesFormFieldNames?: boolean\n    ): any | undefined {\n      const key = usesFormFieldNames ? fieldName : this.formFieldName(fieldName)\n      return this.getData([key], true)[key]\n    },\n  },\n})\n\ndeclare module 'vue/types/options' {\n  interface ComponentOptions<V extends Vue> {\n    fieldValueConvert?(value: any): any\n  }\n}\n\nexport interface FormControlMixin {\n  $options: {\n    /**\n     * Optional function for converting values into this control's native value\n     * format. It will be automatically called whenever some value is applied\n     * to this control, e.g. by a `setFieldsValue` on the supporting form. It is\n     * therefore well-suited for wrapper controls that want to support additional\n     * value types to the ones allowed by the wrapped control.\n     *\n     * The implementor of this function has to ensure that this function behaves\n     * like the identity function for the native value format, since failure to do\n     * so may lead to infinite recursion.\n     */\n    fieldValueConvert?(value: any): any\n  }\n\n  /**\n   * The name of this form control as specified by field decorator.\n   */\n  fieldName: string | null\n\n  /**\n   * Returns whether this form control is used in conjunction with a field decorator.\n   */\n  isDecoratedFormField(): boolean\n\n  /**\n   * Sets the value of this control.\n   */\n  setOwnValue(value: any): void\n  /**\n   * Retrieves the current value of this control.\n   */\n  getOwnValue(): any\n}\n\n/**\n * Mixin providing utility functionality to form controls or AntDV form control\n * wrappers.\n *\n * See type interface for information about the exposed API.\n */\nexport const FormControlMixin = Vue.extend({\n  inject: {\n    FormContext: { default: () => ({}) },\n  },\n  computed: {\n    fieldName(): string | null {\n      if (this.getFormContext() && this.$attrs['data-__field']) {\n        return typing.cast<{ name: string }>(this.$attrs['data-__field']).name\n      } else {\n        return null\n      }\n    },\n  },\n  data() {\n    return {\n      FormControlConvValue: undefined,\n    }\n  },\n  created() {\n    if (this.$options.fieldValueConvert) {\n      const valueProp =\n        this.$options.model && this.$options.model.prop\n          ? this.$options.model.prop\n          : 'value'\n\n      this.$watch(valueProp, (value: any) => {\n        if (this.FormControlConvValue === value) {\n          // Value has already been converted\n          this.FormControlConvValue = undefined\n        } else if (this.$options.fieldValueConvert) {\n          const newValue = this.$options.fieldValueConvert.call(this, value)\n          if (newValue !== value) {\n            this.FormControlConvValue = newValue\n            this.setOwnValue(newValue)\n          }\n        }\n      })\n    }\n  },\n  methods: {\n    getFormContext(): MinimalFormContext {\n      return typing.extended(\n        this,\n        typing.TypeArg<{\n          FormContext: MinimalFormContext\n        }>()\n      ).FormContext\n    },\n    isDecoratedFormField(): boolean {\n      return !!(this.getFormContext() && this.$attrs['data-__field'])\n    },\n    setOwnValue(value: any) {\n      const eventType =\n        this.$options.model && this.$options.model.event\n          ? this.$options.model.event\n          : 'change'\n\n      this.$emit(eventType, value)\n    },\n    getOwnValue() {\n      const valueProp =\n        this.$options.model && this.$options.model.prop\n          ? this.$options.model.prop\n          : 'value'\n      return (this as Record<string, any>)[valueProp]\n    },\n  },\n})\n"],"sourceRoot":""}]}